<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Vue】性能优化初探</title>
      <link href="/2021-11-02-vue-optimization-primary/"/>
      <url>/2021-11-02-vue-optimization-primary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[1] <a href="https://www.infoq.cn/article/9ihyy7HW00ij8suTh*zN">Vue 性能优化：如何实现延迟加载和代码拆分？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSS】如何理解 flex-basis ？</title>
      <link href="/2021-10-20-flex-basis/"/>
      <url>/2021-10-20-flex-basis/</url>
      
        <content type="html"><![CDATA[<h2 id="一、flex-basis-的含义"><a href="#一、flex-basis-的含义" class="headerlink" title="一、flex-basis 的含义"></a>一、flex-basis 的含义</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> 属性 <strong><code>flex-basis</code></strong> 指定了 flex 元素在主轴方向上的初始大小。如果不使用  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing"><code>box-sizing</code></a> 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。</p></blockquote><div class="note info simple"><p><strong>Note</strong>: 当一个元素同时被设置了 <code>flex-basis</code> (除值为 <code>auto</code> 外) 和 <code>width</code> (或者在 <code>flex-direction: column</code> 情况下设置了<code>height</code>) , <code>flex-basis</code> 具有更高的优先级.</p></div><h2 id="二、flex-basis-的使用"><a href="#二、flex-basis-的使用" class="headerlink" title="二、flex-basis 的使用"></a>二、flex-basis 的使用</h2><h3 id="2-1-取值"><a href="#2-1-取值" class="headerlink" title="2.1. 取值"></a>2.1. 取值</h3><table><thead><tr><th>值/类型</th><th>描述</th></tr></thead><tbody><tr><td>auto</td><td>默认值，意为“参照我的 <code>width</code> 和 <code>height</code> 属性”</td></tr><tr><td>number</td><td>宽度值，可以是长度单位（如10px、10em等）或百分数（基于其父弹性盒容器主轴尺寸，若父容器尺寸依赖于子元素，则效果同 <code>auto</code>）</td></tr><tr><td>content</td><td>基于 flex 的元素的内容自动调整大小</td></tr><tr><td>尺寸关键词</td><td><code>fill</code>, <code>max-content</code>, <code>min-content</code>, <code>fit-content</code> 等；</td></tr><tr><td>全局数值</td><td><code>inherit</code>, <code>initial</code>, <code>unset</code> 等。</td></tr></tbody></table><h3 id="2-2-举例说明"><a href="#2-2-举例说明" class="headerlink" title="2.2. 举例说明"></a>2.2. 举例说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    width: 600px;</span><br><span class="line">  &#125;</span><br><span class="line">  .parent &gt; div &#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .item-1 &#123;</span><br><span class="line">    width: 140px;</span><br><span class="line">    flex: 2 1 0%;</span><br><span class="line">    background: blue;</span><br><span class="line">  &#125;</span><br><span class="line">  .item-2 &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    flex: 2 1 auto;</span><br><span class="line">    background: darkblue;</span><br><span class="line">  &#125;</span><br><span class="line">  .item-3 &#123;</span><br><span class="line">    flex: 1 1 200px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;item-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item-2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item-3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol><li><p>父容器主轴宽度为 600px；</p></li><li><p>三个子元素基础宽度分别为 0%（即 0）、auto（同 width，100px ）、 200px，合计 300px；</p></li><li><p>父容器剩余空间为 600px - 300px = 300px;</p></li><li><p>根据 flex-grow 权重 2:2:1，各 item 元素分得的空间宽度分别为</p><div class="note normal simple"><p>item-1：(2/(2+2+1)) * 300px = 120px</p><p>item-2：(2/(2+2+1)) * 300px = 120px</p><p>item-3：(1/(2+2+1)) * 300px = 60px</p></div></li><li><p>故各 item 元素在父 flex 容器内的实际宽度分别为</p><div class="note normal simple"><p>item-1：0% + 120px = 0 + 120px = 120px</p><p>item-2：auto + 120px = 100px + 120px = 220px</p><p>item-3：200px + 120px = 320px</p></div></li></ol><p>flex-basis 可以视为 flex 元素在放进父级 flex 容器之前的大小，是 flex 元素在主轴上伸缩变化的基础值，元素的 grow 和 shrink 都基于这个基础值来确定。 </p><h2 id="三、flex-basis-与-width-的区别"><a href="#三、flex-basis-与-width-的区别" class="headerlink" title="三、flex-basis 与 width 的区别"></a>三、flex-basis 与 width 的区别</h2><p><strong>Flex Items 的应用准则</strong>，即   </p><p><code>content –&gt; width –&gt; flex-basis (limted by max|min-width)</code>。   </p><p>也就是说，</p><div class="note normal simple"><p>若没有设置 flex-basis，则 flex-basis 的值就是 flex 元素的 width；</p><p>若没有设置 width，则 flex-basis 的值就是 flex 元素内容 content 的尺寸；</p><p>若同时设置了 flex-basis 和 width，width 属性将被忽略，元素的伸缩基于 flex-basis 的值。</p></div><div class="note info simple"><p><strong>Note</strong>：flex-basis 受 min-width/max-width/min-height/max-height 限制。</p></div><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><blockquote><p>4.1. <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis">flex-basis - CSS（层叠样式表） | MDN</a></p></blockquote><blockquote><p>4.2. <a href="https://www.cnblogs.com/thinkingthigh/p/10033809.html">Flex Basis与Width的区别</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Developer </category>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub Pages 搭建个人博客</title>
      <link href="/2021-08-02-blog-building/"/>
      <url>/2021-08-02-blog-building/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因 <a href="https://hexo.io/zh-cn/docs/">Hexo 文档</a> 及 <a href="http://moxfive.xyz/yelee/">Yelog配置文档</a> 描述十分详细，本文章仅汇总本人 <a href="https://gitee.com/even_weiss">Even Weiss</a> 在使用 Hexo 搭建个人博客过程中遇到的各种问题和注意事项。诸如 Hexo 的安装等简单的内容均一笔带过，不拓展细说。</p><p><em>吐槽</em>：公司网络访问 github 过于捉急，本想使用 gitee pages ，然而</p><p><img src="/2021-08-02-blog-building/1623424661.png" alt="error"></p><h2 id="一、Github-Pages-介绍及配置"><a href="#一、Github-Pages-介绍及配置" class="headerlink" title="一、Github Pages 介绍及配置"></a>一、Github Pages 介绍及配置</h2><p>Github Pages，是 <code>github</code> 多种服务之一。同时，如官网的标语 <code>Websites for you and your projects</code>，也是一个个人静态网站。</p><h3 id="1-1-配置步骤："><a href="#1-1-配置步骤：" class="headerlink" title="1.1. 配置步骤："></a>1.1. 配置步骤：</h3><ol><li>注册一个 Github 账号（下文用 username 代指该账号用户名（注意：用户名非昵称））；</li><li>新建一个以 <code>username.github.io</code> 为名的仓库；</li></ol><h3 id="1-2-测试访问"><a href="#1-2-测试访问" class="headerlink" title="1.2. 测试访问"></a>1.2. 测试访问</h3><ol><li>仓库中新建一个 <code>index.html</code> 文件，内容随意；</li><li>访问地址 <code>https://username.github.io</code>，若正常显示 <code>index.html</code> 的内容，则说明启用 <code>github pages</code> 服务成功。</li></ol><h2 id="二、Hexo-介绍-amp-安装"><a href="#二、Hexo-介绍-amp-安装" class="headerlink" title="二、Hexo 介绍 &amp; 安装"></a>二、Hexo 介绍 &amp; 安装</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>详见<a href="https://hexo.io/zh-cn/docs/">文档</a>。</p><h2 id="三、Hexo-基本配置"><a href="#三、Hexo-基本配置" class="headerlink" title="三、Hexo 基本配置"></a>三、Hexo 基本配置</h2><h3 id="3-1-创建新文章（post）"><a href="#3-1-创建新文章（post）" class="headerlink" title="3.1. 创建新文章（post）"></a>3.1. 创建新文章（post）</h3><ol><li>通过命令 <code>hexo new &lt;title&gt;</code> 创建新文章 <em>md</em> 文件；</li><li>通过配置项 <em>new_post_name</em> 修改生成的 md 文件名，如 <code>new_post_name: :year-:month-:day-:title.md</code> 配置下，命令 <code>hexo new hello-world</code> 将生成名为 “<em>2021-08-02-blog-building.md</em>“ 的文件，若同时配置了 <code>post_asset_folder: true</code>，还会生成同名目录 /2021-08-02-blog-building/；</li></ol><h3 id="3-2-资源文件目录"><a href="#3-2-资源文件目录" class="headerlink" title="3.2. 资源文件目录"></a>3.2. 资源文件目录</h3><ol><li><p>若博客仅使用少量静态资源，如图片，可以将静态文件放置于 /source/[class]/ 目录下，如 /source/images/ 放置图片，使用相对路径引入；</p></li><li><p>若希望每个文章都使用独立的静态文件，那么需要打开资源文件管理功能，在配置文件中设置 <code>post_asset_folder: true</code> 即可；</p><ul><li><p>资源文件管理功能打开后，每次使用 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时会自动创建一个同名文件夹，用于存放静态资源，目录结构如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\---_posts</span><br><span class="line">    |   2021-08-02-blog-building.md</span><br><span class="line">    \---2021-08-02-blog-building</span><br><span class="line">            1623424661.png</span><br><span class="line">            1623726453.png</span><br></pre></td></tr></table></figure></li><li><p>若使用资源文件管理功能（<code>post_asset_folder: true</code>），文章 <em>md</em> 文件中引入图片等静态文件时，不可以使用相对路径，而应该使用 <strong>url 路径</strong>。</p><p>举例来说：</p><p><em>_config.yml</em> 中默认配置以下两项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">permalink: :year/:month/:day/:title/ // 发布后访问博客文章 path 地址格式，默认 :year/:month/:day/:title/</span><br><span class="line">new_post_name: :year-:month-:day-:title.md // hexo new [title] 命令生成的 md 文件名声格式</span><br></pre></td></tr></table></figure><p>按上面这种默认配置， 文章访问地址为 <code>https://username.github.io/2021/08/02/blog-building</code> 。</p><p>如果我们将文章使用的图片（假设为 <em>sample.png</em>）放在 <code>/source/2021-08-02-blog-building/</code> 目录。为保证发布后图片能够正常显示，在文章 markdown 中我们需要这样引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt](/2021/06/11/hello-world/sample.png)</span><br></pre></td></tr></table></figure><p>但，因路径与本地实际路径不符，本地编辑 markdown 时，将无法正常显示该图片。必须通过 <code>hexo s</code> 命令启动 Hexo 项目，在文章页进行预览，造成不必要的麻烦。</p><p>因此，建议 <code>permalink</code> 与 <code>new_post_name</code> 保持一致，如下面这种配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">permalink: :year-:month-:day-:title/</span><br><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure><p>文章访问地址为 <code>https://username.github.io/2021-08-02-blog-building</code> ；markdown 文件中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt](/2021-08-02-blog-building/sample.png)</span><br></pre></td></tr></table></figure><p>如此，文件的 <em>url</em> 路径与本地路径相同，编辑文章时方便预览图片，发布后也可以正常显示。</p></li></ul></li></ol><h3 id="3-3-分类-amp-标签"><a href="#3-3-分类-amp-标签" class="headerlink" title="3.3. 分类&amp;标签"></a>3.3. <a href="https://hexo.io/zh-cn/docs/front-matter#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE">分类&amp;标签</a></h3><p><strong>注意：</strong>Hexo 不支持指定多个<strong>同级分类</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure><p>会使分类 <em>Life</em> 成为 <em>Diary</em> 的子分类，而不是并列分类。若需要设置并列分类，使用下列语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p><h2 id="四、Hexo-主题-–-Theme-Yelee"><a href="#四、Hexo-主题-–-Theme-Yelee" class="headerlink" title="四、Hexo 主题 – Theme Yelee"></a>四、Hexo 主题 – Theme Yelee</h2><p>旧版博客使用 <a href="https://github.com/yelog/hexo-theme-yelog">Yelee</a> 主题。</p><h3 id="4-1-主题配置"><a href="#4-1-主题配置" class="headerlink" title="4.1. 主题配置"></a>4.1. 主题配置</h3><p>Yelee 的配置项有很多，这里简单的介绍几项，其他的参考<a href="http://moxfive.xyz/yelee/">官方文档</a>啦~</p><h4 id="4-1-1-基础配置"><a href="#4-1-1-基础配置" class="headerlink" title="4.1.1. 基础配置"></a><span id="theme-basic-config">4.1.1. 基础配置</span></h4><p>自 Hexo 5.0.0 起，可以使用<strong>独立的</strong> <em>/_config.[theme].yml</em> 文件，对主题进行配置。</p><p>官方也推荐“<code>将所有的主题配置集中在一处</code>”，故而我的博客主题配置在文件 <em>/_config.yelee.yml</em> 中，方便配置。</p><p>建议将 <em>/themes/[theme]/_config.yml</em> 的内容移动到 <em>/_config.[theme].yml</em> 中，并清空原文件内容。如此，当我们需要注释掉一些不需要的配置时，主题不会读取 <em>/themes/[theme]/_config.yml</em> 的配置内容。</p><h4 id="4-1-2-专项配置"><a href="#4-1-2-专项配置" class="headerlink" title="4.1.2. 专项配置"></a>4.1.2. 专项配置</h4><ol><li><p>注意更换博客个人头像、网页小图标、苹果图标；</p></li><li><p>author 与 subtitle：</p><p>说明文档未著明，配置项 author 影响左侧头像下方个人名称和文章版权author 的显示；subtitle影响左侧头像名称下方副标题的显示。建议配置，效果如下：</p><p><img src="/2021-08-02-blog-building/1623750958.png" alt="author/subtitle"></p></li><li><p>菜单配置：</p><p><img src="/2021-08-02-blog-building/1623726453.png" alt="左侧菜单"></p></li></ol><p>   页面左侧菜单可以在配置文件的 <code>menu</code> 项进行设置。默认配置的主页、所有文章、标签云、关于我四个菜单项，路径尽量不要进行更改。</p><p>   若想添加自定义菜单，可以在 <code>themes/yelee/_config.yml</code> 或者 <code>_config.yelee.yml</code> 的 <code>menu</code> 项中进行额外配置。</p><p>   自定义菜单链接的页面大致有两种类型：</p><ol><li>一为标签，展示同一标签的文章列表，配置路径为 <code>/tags/[tagName]</code>，如 <code>menu: 建站日志: /tags/建站日志</code>；</li><li>二为文章，展示同文章页，配置路径为文章 <strong>url 路径</strong>，如 <code>menu: 建站日志: /2021/06/11/hello-world/</code>。</li></ol><h4 id="4-1-3-页面配置"><a href="#4-1-3-页面配置" class="headerlink" title="4.1.3. 页面配置"></a>4.1.3. 页面配置</h4><ol><li><p>主页显示文章摘要 excerpt：</p><p>有两种方式，可以在 front matter 中加入 description 描述（仅支持文本）；也可以在正文内容加一行 <code>&lt;!-- more --&gt;</code>（注意顶格写），<code>&lt;!-- more --&gt; </code> 前面的内容就会显示在主页的摘要。</p><p>个人推荐第二种。</p><p>目前版本这个配置有问题，详情参见 <a href="#theme-Q1">问题汇总 Q1</a>。</p></li><li><p>标签云、关于我页面：</p><p>注意使用 <code>hexo new page &lt;pageName&gt;</code> 生成 about 和 tabs 两个页面，用于主页菜单显示，不用的话记得在配置（menu）中注释掉。</p><p>标签云 tabs 页面为默认样式，会自动汇总各文章的标签、分类。可以在 <code>source/tags/index.md</code> 文件中，可以修改 title 更换页面标题。</p><p>关于我页面与文章页面样式相同，可以在 <code>source/about/index.md</code> 中编辑页面标题及内容。</p></li><li><p>文章目录</p><p>全局配置 <code>toc: on: true</code> 或文章 front matter 配置 <code>toc: true</code> 启用文章目录。</p><p>建议全局配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// _config.yelee.yml</span><br><span class="line">toc:</span><br><span class="line">  list_number: false</span><br><span class="line">  max_depth: 6</span><br><span class="line">  nowrap: true</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-2-问题汇总"><a href="#4-2-问题汇总" class="headerlink" title="4.2. 问题汇总"></a>4.2. 问题汇总</h3><p><b id="theme-Q1">Q1.</b> 按<a href="http://moxfive.xyz/yelee/2.Basic-Usage/post-excerpt.html">文档说明</a>处理，无法将文章摘要显示在首页</p><p><strong>问题原因：</strong></p><p>themes/yelee/layout/_partial/head.ejs* 中 <code>search: &lt;%= theme.search.on %&gt;</code> 定义有问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var yiliaConfig = &#123;</span><br><span class="line">        ...</span><br><span class="line">        search: &lt;%= theme.search.on %&gt; // 注意这一句</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>注意这里的 “search”，取值是 “on”，而在 <em>yelee</em> 主题的配置文件里默认设置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// themes/yelee/_config.yml</span><br><span class="line">search:</span><br><span class="line">  #on: true</span><br><span class="line">  onload: false</span><br><span class="line">  ## true: get search.xml file when the page has loaded</span><br><span class="line">  ## false: get the file when search box gets focus</span><br></pre></td></tr></table></figure><p>配置项 “on” 被注释，导致 <code>Uncaught ReferenceError: yiliaConfig is not defined</code> 报错。</p><p><strong>解决方案：</strong></p><p>配置 on 选项即可，比如: <em>themes/yelee/_config.yml</em> 中取消注释（我的博客直接在 <em>_config.yelee.yml</em> 中配置 <code>search: on: true</code>）。</p><p><strong>参考</strong></p><blockquote><ol><li><a href="https://paradiseduo.blog.csdn.net/article/details/78709160?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">Hexo 中的 Yelee 主题，首页不显示文章摘要</a></li><li><a href="http://moxfive.xyz/yelee/2.Basic-Usage/local-site-search.html">Yelee 主题使用说明/本地站内搜索</a></li></ol></blockquote><p><strong>Q2.</strong> 主菜单社交图标中，GitHub 图标丢失</p><p><strong>问题原因：</strong></p><p>主题文件中所引用的 GitHub 图标地址为 “//cdn.bootcss.com/logos/0.2.0/github-octocat.svg” 已失效</p><p><strong>解决方案：</strong></p><p>替换图标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// themes/yelee/source/css/_partial/customise/social-icon.styl 文件中</span><br><span class="line">// 修改</span><br><span class="line">.GitHub</span><br><span class="line">    background url(//cdn.bootcss.com/logos/0.2.0/github-octocat.svg) no-repeat white</span><br><span class="line">    background-size 90%</span><br><span class="line">    background-position 50% 100%</span><br><span class="line">// 为</span><br><span class="line">.GitHub</span><br><span class="line">    background url(https://github.com/favicon.ico) no-repeat white</span><br><span class="line">    background-size 100%</span><br></pre></td></tr></table></figure><p><strong>Q3.</strong> 不蒜子统计不显示</p><p><strong>问题原因：</strong></p><p>引入的js文件地址失效</p><p><strong>解决方案：</strong></p><p>更新地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// themes/yelee/layout/_partial/after-footer.ejs</span><br><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">// 替换为</span><br><span class="line">&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>参考：</strong></p><blockquote><p><a href="http://ibruce.info/2015/04/04/busuanzi/xxxxxxxxxx">http://ibruce.info/2015/04/04/busuanzi/xxxxxxxxxx</a><br><a href="http://ibruce.info/2015/04/04/busuanzi/">http://ibruce.info/2015/04/04/busuanzi/</a></p></blockquote><h2 id="五、Hexo-主题-–-Theme-Butterfly"><a href="#五、Hexo-主题-–-Theme-Butterfly" class="headerlink" title="五、Hexo 主题 – Theme Butterfly"></a>五、Hexo 主题 – Theme Butterfly</h2><p>原使用 <em>Yelee</em> 主题，重构后更换为 <em>butterfly</em> 主题，版本号：3.8.4。</p><h3 id="5-1-主题介绍"><a href="#5-1-主题介绍" class="headerlink" title="5.1. 主题介绍"></a>5.1. 主题介绍</h3><p>主题示例与使用说明见 <a href="https://butterfly.js.org/">https://butterfly.js.org/</a> 。</p><h3 id="5-2-配置要点及教程"><a href="#5-2-配置要点及教程" class="headerlink" title="5.2. 配置要点及教程"></a>5.2. 配置要点及教程</h3><p>基础配置部分见 <a href="#theme-basic-config">第四部分-4.1.1</a>。</p><h4 id="5-2-1-配置要点"><a href="#5-2-1-配置要点" class="headerlink" title="5.2.1. 配置要点"></a>5.2.1. 配置要点</h4><ol><li>Butterfly 主题支持 <a href="https://fontawesome.com/icons?from=io">font-awesome v5</a> 图标；若需要使用其他图标，参考<a href="https://butterfly.js.org/posts/4073eda/#Icon">教程-Icon</a>。</li></ol><h4 id="5-2-2-部分教程导航"><a href="#5-2-2-部分教程导航" class="headerlink" title="5.2.2. 部分教程导航"></a>5.2.2. 部分教程导航</h4><ol><li><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E9%A0%82%E9%83%A8%E5%9C%96">顶部图</a></p></li><li><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%96%87%E7%AB%A0%E9%A0%81%E7%9B%B8%E9%97%9C%E9%85%8D%E7%BD%AE">文章页相关配置</a></p></li><li><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">标签外挂、图库等</a></p></li></ol><h4 id="5-2-3-注意事项"><a href="#5-2-3-注意事项" class="headerlink" title="5.2.3. 注意事项"></a>5.2.3. 注意事项</h4><ol><li>配置 <em>Waline</em> 时，若未注册 <em>vercel</em>，第一次进入时会提示注册。注册完成后，建议关闭 <em>vercel</em> 页面，再次从 <a href="https://waline.js.org/guide/get-started.html#vercel-%E9%83%A8%E7%BD%B2-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><em>Waline</em> 教程页面</a> 点击 Deploy 按钮进入 <em>vercel</em> ，此时 <em>vercel</em> 会默认选择 <em>Waline</em> 模板。</li><li>配置 <em>Waline</em> 时，在 <em>vercel</em> 填写的 <em>Team</em> 名会影响最后生成的服务器地址链接，建议慎重填写。</li><li>配置 <em>Waline</em> 时，已经创建的 <em>vercel Team</em> 可以在 <em>vercel</em> 页面点击顶部导航栏–用户名右侧的按钮（<strong>上下箭头</strong>）找到。</li><li>需要将主题分支切换至 master 分支，master 分支为稳定版。</li></ol><h3 id="5-3-问题汇总"><a href="#5-3-问题汇总" class="headerlink" title="5.3. 问题汇总"></a>5.3. 问题汇总</h3><p><strong>Q1.</strong> 本地运行，主页，点击文章图片/标题调用浏览器下载，而不是打开文章页面。</p><p><strong>A1.</strong> _config.yml 中配置 <code>permalink</code> 时，最后未加斜线 <code>/</code> 导致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: :year-:month-:day-:title/</span><br></pre></td></tr></table></figure><p>修改 <code>permalink</code> 时，最后的斜线 <code>/</code> 需保留。</p><p><strong>Q2.</strong> clone 主题文件后，希望将博客配置项目上传至远端仓库，<code>git add .</code> 命令报错如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">warning: adding embedded git repository: themes/butterfly</span><br><span class="line">hint: You&#x27;ve added another git repository inside your current repository.</span><br><span class="line">hint: Clones of the outer repository will not contain the contents of</span><br><span class="line">hint: the embedded repository and will not know how to obtain it.</span><br><span class="line">hint: If you meant to add a submodule, use:</span><br><span class="line">hint:</span><br><span class="line">hint:   git submodule add &lt;url&gt; themes/butterfly</span><br><span class="line">hint:</span><br><span class="line">hint: If you added this path by mistake, you can remove it from the</span><br><span class="line">hint: index with:</span><br><span class="line">hint:</span><br><span class="line">hint:   git rm --cached themes/butterfly</span><br><span class="line">hint:</span><br><span class="line">hint: See &quot;git help submodule&quot; for more information.</span><br></pre></td></tr></table></figure><p><strong>A2.</strong> 存在两个 <code>.git</code> 目录。</p><p>git 原则上不建议上传两个项目至同一个仓库。</p><p>这里使用子模块进行上传：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached themes/butterfly -f</span><br><span class="line">$ git submodule add https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;***&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><p>clone 时，仅下载主项目文件，子模块文件需要另行下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://gitee.com/even_weiss/my-blog-building.git</span><br><span class="line">$ git submodule init &amp;&amp; git submodule update</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://gitee.com/even_weiss/my-blog-building.git --recursive</span><br></pre></td></tr></table></figure><p>需要 update 子模块时，需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd themes/butterfly</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>或更新全部子模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule foreach git submodule update</span><br></pre></td></tr></table></figure><p><strong>Q3.</strong> 配置本地图片（如 <code>/_images/avatar.jpg</code>），显示错误的问题</p><p><strong>A3.</strong> 图片地址错误，地址中不可以存在下划线 <code>_</code> 等特殊字符。建议将图片放在 <code>/source/images/</code> 目录下。</p><p>配置示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Favicon（網站圖標）</span><br><span class="line">favicon: /images/avatar.jpg</span><br></pre></td></tr></table></figure><p>也可以使用 url 链接。</p><p><strong>Q4.</strong> 配置打赏相关二维码图片（本地）后，图片高度为 0 的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reward:</span><br><span class="line">  enable: true</span><br><span class="line">  QR_code:</span><br><span class="line">    - img: /img/sponsor/wechat.jpg</span><br><span class="line">      link:</span><br><span class="line">      text: 微信</span><br><span class="line">    - img: /img/sponsor/alipay.jpg</span><br><span class="line">      link:</span><br><span class="line">      text: 支付宝</span><br></pre></td></tr></table></figure><p><strong>A4.</strong> 仅针对打赏 Reward 模块，有这样一个设定：</p><p>若图片存放目录为 <code>/source/img</code> 则不能嵌套，只能放在 <code>/source/img/</code> 目录下；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img[src$=&quot;/img/sponsor/wechat.jpg&quot;] &#123;</span><br><span class="line">    display: none !important;</span><br><span class="line">    visibility: hidden !important;</span><br><span class="line">    height: 0px !important;</span><br><span class="line">    min-height: 0px !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若嵌套目录，则有上面这样一个 <code>injected stylesheet</code> ，原因不明；</p><p>若图片存放目录为 <code>/source</code> 下的其他目录，如 <code>/source/images/</code>， 则可以随意嵌套。</p><p><strong>Q5.</strong> 侧边栏“最新评论”模块显示“无法获取评论，请确认相关配置是否正确”，且控制台报错跨域。</p><p><strong>A5.</strong> 解析如下</p><p><strong>问题原因：</strong></p><p>评论配置错误。</p><p>本博客使用 <code>Waline</code> 实现评论功能，配置时需录入 serverUrl 一项，错误配置为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Waline</span><br><span class="line">  serverURL: https://*-sepia.vercel.app/</span><br><span class="line">// * 代表 vercel 配置的 Team 名</span><br></pre></td></tr></table></figure><p>最后多加了一条斜线 <code>/</code> ，导致获取最新评论时，请求地址错误，为 <code>https://waline-api-sepia.vercel.app//comment?type=recent&amp;count=6</code>，双斜线 <code>//</code> 导致跨域。</p><p><strong>解决方案：</strong></p><p>去掉最后的斜线 <code>/</code> 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Waline</span><br><span class="line">  serverURL: https://*-sepia.vercel.app</span><br><span class="line">// * 代表 vercel 配置的 Team 名</span><br></pre></td></tr></table></figure><h3 id="5-4-魔改"><a href="#5-4-魔改" class="headerlink" title="5.4. 魔改"></a>5.4. 魔改</h3><ol><li>调整滚动条颜色为蓝紫渐变；</li><li>调整 footer 部分为渐变蓝紫绿三色渐变动画；</li></ol><p><strong>参考：</strong></p><blockquote><p> <a href="https://blog.csdn.net/u012208219/article/details/106883001/">https://blog.csdn.net/u012208219/article/details/106883001/</a></p></blockquote><h2 id="六、预览及发布"><a href="#六、预览及发布" class="headerlink" title="六、预览及发布"></a>六、预览及发布</h2><h3 id="6-1-预览-Preview"><a href="#6-1-预览-Preview" class="headerlink" title="6.1. 预览 Preview"></a>6.1. 预览 Preview</h3><h4 id="6-1-1-启动本地服务器"><a href="#6-1-1-启动本地服务器" class="headerlink" title="6.1.1. 启动本地服务器"></a>6.1.1. <a href="https://hexo.io/zh-cn/docs/server">启动本地服务器</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>也可以简写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>项目将在 <code>http://localhost:4000</code> 地址启动。</p><h3 id="6-2-发布-Publish"><a href="#6-2-发布-Publish" class="headerlink" title="6.2. 发布 Publish"></a>6.2. 发布 Publish</h3><h4 id="6-2-1-Github-Pages"><a href="#6-2-1-Github-Pages" class="headerlink" title="6.2.1. Github Pages"></a>6.2.1. Github Pages</h4><h4 id="6-2-2-Gitee-Pages"><a href="#6-2-2-Gitee-Pages" class="headerlink" title="6.2.2. Gitee Pages"></a>6.2.2. Gitee Pages</h4><h4 id="6-2-3-发布流程"><a href="#6-2-3-发布流程" class="headerlink" title="6.2.3. 发布流程"></a>6.2.3. 发布流程</h4><ol><li><p><a href="https://hexo.io/zh-cn/docs/generating">生成文件</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>也可以简写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></li><li><p><a href="https://hexo.io/zh-cn/docs/one-command-deployment">一键部署</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>也可以简写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-3-常见问题汇总"><a href="#6-3-常见问题汇总" class="headerlink" title="6.3. 常见问题汇总"></a>6.3. 常见问题汇总</h3><p><strong>Q1.</strong> <code>hexo d</code> 发布时，远程仓库连接超时、断开连接等各种push代码失败的问题</p><p><strong>A1.</strong> 解析如下</p><p><strong>问题原因：</strong></p><ol><li>网络问题；</li><li>hexo 或 github 配置问题，hexo 对 https 推送方式的使用有问题；</li><li>其他原因；</li></ol><p><strong>解决方案：</strong></p><ol><li><p>检查网络配置，看是否对 github 有限制；</p></li><li><p>https 方式改为 ssh 方式，github 配置步骤参考本文 <a href="https://blog.csdn.net/lqlqlq007/article/details/78983879">git ssh key配置</a>，hexo 项目配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// ./_config.yml</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:evenweiss/evenweiss.github.io.git // 修改这个地方，将 http 换为 ssh 地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></li></ol><p><strong>Q2.</strong> 对已有博客进行更新，命令行提示 <code>nothing to commit, working tree clean</code> 及 <code>Everything up-to-date</code> ，无更新的问题</p><p><img src="/2021-08-02-blog-building/1627525252.png"></p><p><strong>A2.</strong> 解析如下</p><p><strong>问题原因：</strong></p><p><code>hexo d</code> 并不能监听项目文件的变动，且当我们的项目根目录中存在 <code>/public</code> 目录时，该命令会直接复制 <code>/public</code> 的内容，而不生成新的 public。</p><p><strong>解决方案：</strong></p><p>每次更新：</p><ol><li><p>手动或 <code>hexo clean</code> 删除 <code>/public</code> 目录，再通过 <code>hexo d</code> 生成新的目录；</p></li><li><p>使用 <code>hexo generate</code> 更新 public 后，再通过 <code>hexo d</code> 发布；</p></li><li><p>使用下面两个命令中的一个进行部署发布，两个命令作用相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate --deploy 缩写为 hexo g -d</span><br><span class="line">$ hexo deploy --generate 缩写为 hexo d -g</span><br></pre></td></tr></table></figure></li></ol><p><strong>Q3.</strong> 通过命令 <code>hexo d --generate</code> 发布时，报错 <code>ERROR Deployer not found: git</code><br><strong>A3.</strong> 解析如下</p><p><strong>问题原因：</strong></p><p>缺少插件 <em>hexo-deployer-git</em> ；</p><p><strong>解决方案：</strong></p><p>安装 <em>hexo-deployer-git</em> 插件即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h3 id="7-1-工具"><a href="#7-1-工具" class="headerlink" title="7.1. 工具"></a>7.1. 工具</h3><ol><li><mark class="hl-label green">CDN</mark>  https://www.jsdelivr.com/</li><li><mark class="hl-label purple">图床</mark>  https://sm.ms/</li><li><mark class="hl-label blue">JS/HTML/CSS在线压缩</mark>  https://tool.oschina.net/jscompress/</li><li><mark class="hl-label orange">fontawesome图标库</mark>  https://fontawesome.com/v5.15/icons?from=io</li></ol><h3 id="7-2-参考文献"><a href="#7-2-参考文献" class="headerlink" title="7.2. 参考文献"></a>7.2. 参考文献</h3><blockquote><p>hexo 官方文档 <a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p>yelee 主题使用说明 <a href="http://moxfive.xyz/yelee/">http://moxfive.xyz/yelee/</a></p><p>butterfly 主题使用说明 <a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>Hexo 搭建：配置 Rss 订阅功能 <a href="https://blog.csdn.net/qq_36537546/article/details/90730068">https://blog.csdn.net/qq_36537546/article/details/90730068</a></p><p>jsDeliver+github打造属于自己的图床 <a href="https://blog.csdn.net/weixin_45631738/article/details/104731332">https://blog.csdn.net/weixin_45631738/article/details/104731332</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JavaScript】(0, function)() 语句解析</title>
      <link href="/2021-07-29-comma-operator/"/>
      <url>/2021-07-29-comma-operator/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今日，在阅读 <code>vant</code> 组件源码时，发现了这样的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var _createNamespace = (0, _utils.createNamespace)(&#x27;radio&#x27;)</span><br></pre></td></tr></table></figure><p>偶尔也会在其他一些地方见到类似的，如 <code>webpack4</code> 源码中有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test2 = (0, _test2.default)();</span><br></pre></td></tr></table></figure><span id="more"></span><p>抽象一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0, function)();</span><br></pre></td></tr></table></figure><p><strong>提问：</strong>这个语法的结果是什么？使用这个语法的意义又是什么？</p><h2 id="一、逗号操作符"><a href="#一、逗号操作符" class="headerlink" title="一、逗号操作符"></a>一、逗号操作符</h2><p><code>MDN</code> 上对”逗号操作符”的解释为<code>对它的每个操作数求值（从左到右），并返回最后一个操作数的值。</code></p><h3 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1. 使用场景"></a>1.1. 使用场景</h3><p>大致上，需要用到逗号操作符大致有下面两种情况：</p><ol><li><p><code>当你想要在期望一个表达式的位置包含多个表达式时，可以使用逗号操作符。</code></p><p>举例来说，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 多变量循环</span><br><span class="line">for (var i = 0, j = 9; i &lt;= 9; i++, j--)</span><br><span class="line">  document.writeln(&quot;a[&quot; + i + &quot;][&quot; + j + &quot;] = &quot; + a[i][j]);</span><br></pre></td></tr></table></figure><p>上例中，<code>i++, j--</code> 这个部分应用了逗号操作符。</p></li><li><p><code>另一个使用逗号操作符的例子是在返回值前处理一些操作。</code></p><p>举例来说，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function myFunc () &#123;</span><br><span class="line">  var x = 0;</span><br><span class="line">  return (x += 1, x); // 同 return ++x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>(x += 1, x)</code> 便是对逗号操作符的应用：先执行语句 <code>x += 1</code>，再执行语句 <code>x</code> ，最后返回语句 <code>x</code> 的执行结果，即值 <code>x</code>。</p></li></ol><p><strong><em>注意：</em><strong>逗号操作符只返回</strong>最后一个语句</strong>的<strong>执行结果</strong>。前面的<strong>只执行，不返回</strong>。</p><h2 id="二、-0-function"><a href="#二、-0-function" class="headerlink" title="二、(0, function)();"></a>二、(0, function)();</h2><p>很明显，<code>(0, function)();</code> 这个语句就是使用了逗号操作符。</p><p>当然，我们也可以写<code>(true, function)();</code> 或者 <code>(1, function)();</code>，都是一个意思：取出 <code>function</code> 并执行。</p><p>那么，为什么要用这种方式执行 <code>function</code> 呢？直接调用不行么？</p><p>如果只是简单的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">(0, function)();</span><br></pre></td></tr></table></figure><p>这样使用是没有意义的，等同于直接调用 <code>function</code>。</p><p>那，如果我们这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  fun() &#123; console.log(this); &#125;</span><br><span class="line">&#125;</span><br><span class="line">(0, obj.fun)();</span><br></pre></td></tr></table></figure><p>上面这串代码，我们用 <code>node</code> 执行，输出 <code>global</code> 对象；在浏览器执行，输出 <code>window</code> 对象。</p><p>如果我们像这样 <code>obj.func();</code> 直接执行，得到的就会是 <code>obj</code> 对象了。</p><p>如此，我们得出结论：</p><p><code>(0, function)();</code> 可以让 <code>function</code> 的 <code>this</code> 指向全局对象（严格模式下指向 <code>undefined</code>）。</p><p>实际上，无论是 <code>vant</code> 还是 <code>webpack4</code> 都是这种用法，而且 <code>obj</code> 是 <code>require</code> 的模块对象。如 <code>vant</code> 中，有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var _utils = require(&quot;../utils&quot;);</span><br><span class="line">...</span><br><span class="line">var _createNamespace = (0, _utils.createNamespace)(&#x27;radio&#x27;)</span><br></pre></td></tr></table></figure><p>如果直接调用 <code>_utils.createNamespace</code>，那么方法内的 <code>this</code> 必定指向 <code>_utils</code> 这个对象，不能满足要求。</p><hr><p><strong><em>[参考]</em></strong></p><blockquote><ol><li>[MDN-逗号操作符] (<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comma_Operator">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comma_Operator</a>)</li><li><a href="https://stackoverflow.com/questions/32275135/why-does-babel-rewrite-imported-function-call-to-0-fn">Why does babel rewrite imported function call to (0, fn)(…)?</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Developer </category>
          
          <category> Language </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Node】Node 中的 var 声明</title>
      <link href="/2021-07-29-node-var/"/>
      <url>/2021-07-29-node-var/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在练习 JavaScript 时遇到一个有意思的问题：</p><p>我有这样一段代码，最外层写着</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">console.log(this.x);</span><br></pre></td></tr></table></figure><p>当我习惯性地使用 <code>node</code> 命令运行这个 <code>js</code> 文件时，打印出了 <code>undefined</code> ，而非预期的 <code>10</code>。</p><p>查阅部分资料获知原因，本篇文章用于记录此事。</p><span id="more"></span><h2 id="Window-中的-var-声明"><a href="#Window-中的-var-声明" class="headerlink" title="Window 中的 var 声明"></a>Window 中的 var 声明</h2><p>window 中，不使用关键字声明的变量，和在最外层声明的变量都是全局变量 window 的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 10;</span><br><span class="line">console.log(x, window.x); // 10, 10</span><br><span class="line">var y = 20;</span><br><span class="line">console.log(y, window.y); // 20, 20</span><br></pre></td></tr></table></figure><h2 id="Node-中的-var-声明"><a href="#Node-中的-var-声明" class="headerlink" title="Node 中的 var 声明"></a>Node 中的 var 声明</h2><p>Node 中，没有全局变量 <code>window</code>，取而代之的是 <code>global</code>。关键字 <code>this</code> 也指向 <code>global</code>。声明分两种情况：</p><ol><li><p><code>REPL</code> 中，同 <code>window</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 10;</span><br><span class="line">console.log(x, this.x, global.x); // 10, 10, 10</span><br><span class="line">var y = 20;</span><br><span class="line">console.log(y, this.y, global.y); // 20, 20, 20</span><br></pre></td></tr></table></figure></li><li><p>模块中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 不使用关键字声明的变量为全局变量</span><br><span class="line">x = 10;</span><br><span class="line">console.log(x, this.x, global.x); // 10, 10, 10</span><br><span class="line"></span><br><span class="line">// 使用关键字声明的变量为模块私有的变量，非全局变量</span><br><span class="line">var y = 20;</span><br><span class="line">console.log(y, this.y, global.y); // 20, undefined, undefined</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Developer </category>
          
          <category> Tool </category>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSS】Flex 布局中 overflow 失效的问题探讨</title>
      <link href="/2021-07-19-flex-overflow/"/>
      <url>/2021-07-19-flex-overflow/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因开发需要，父级元素 <code>div</code> 有 <code>flex: 1;</code> 属性，需要子元素 <code>p</code> 的文字超出范围的以省略号显示，正常配置后发现 <code>p</code> 元素的内容将上级元素撑开，而未正确隐藏。</p><p>后查阅资料解决，记录备忘。</p><span id="more"></span><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>简化代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  * &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  .root &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  .root .left &#123;</span><br><span class="line">    flex: none;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: blueviolet;</span><br><span class="line">  &#125;</span><br><span class="line">  .root .right &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">    background-color: burlywood;</span><br><span class="line">  &#125;</span><br><span class="line">  .root .right .content &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;root&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">    &lt;p class=&quot;content&quot;&gt;石室诗士施氏，嗜狮，誓食十狮。施氏时时适市视狮。十时，适十狮&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>预期 <code>p.content</code> 元素内容超出的部分以省略号显示；实际文字未隐藏，而是将父级元素撑开，使父级元素宽度超过 100%。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>以上例为基础，列举可用方案如下：</p><ol><li>父级 <code>div.right</code> 设置属性 <code>overflow: hidden;</code> ；</li><li>父级 <code>div.right</code> 设置属性 <code>min-width</code> 为常量（非百分比），建议设为 0，推荐；</li><li>父级 <code>div.right</code> 设置属性 <code>max-width</code> 为常量（非百分比），不建议使用该方法，因为适配问题，难以计算合适的常量；</li><li>父级 <code>div.right</code> 设置属性 <code>width</code> 为常量（非百分比），建议设为 0；</li></ol><h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><p>目前网上搜罗的资料没有合理的解释，仅提供了解决方案，而未说明该方法为什么可以解决此问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="https://www.cnblogs.com/wuxianqiang/p/9282040.html">flex 布局下 overflow 失效问题</a></li><li><a href="https://stackoverflow.com/questions/21515042/scrolling-a-flexbox-with-overflowing-content">Scrolling a flexbox with overflowing content</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Developer </category>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JavaScript】手写 Promise 的一次完整尝试（未完成）</title>
      <link href="/2021-06-30-achive-promise/"/>
      <url>/2021-06-30-achive-promise/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果我们想要深入地学习 JavaScript，那么手写 Promise 无可避免。</p><p>手写 Promise 需要使用多种技术手段和逻辑思路，对学习 JavaScript 或者其他语言、框架等都可以起到积极的作用。</p><p>本篇文章详细记录笔者尝试实现 Promise 的每个步骤以及在此过程中遇到的各种问题。</p><span id="more"></span><h2 id="Promises-A-规范"><a href="#Promises-A-规范" class="headerlink" title="Promises/A+ 规范"></a>Promises/A+ 规范</h2><p>Promise 并不是一个新事物，而是按照一个规范实现的类。这个规范有多个版本，如 Promises/A、Promises/B、Promises/D 以及 Promises/A+ 等。ES6 采用 <a href="https://promisesaplus.com/">Promises/A+</a> 这一版，那么我们自然也就按照这一版来实现 Promise。</p><p>Promises/A+ 规范包含术语（Terminology）、要求（Requirements）和注意事项（Notes）3 个部分。我们主要按第二部分逐步实现 Promise。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="I-Promise-States"><a href="#I-Promise-States" class="headerlink" title="I. Promise States"></a>I. Promise States</h3><ol><li><p>一个合乎规范的 promise 应该有 <code>pending</code>、<code>fulfilled</code>、<code>rejected</code> 三个状态；</p></li><li><p>promise 的状态可以由 pending 转为 <code>fulfilled</code> 或者 <code>rejected</code>，这个转换过程不可逆；</p></li><li><p><code>fulfilled</code> 和 <code>rejected</code> 状态不可再转变为其他状态；</p></li><li><p>当 promise 状态由 <code>pending</code> 转变为 <code>fulfilled</code> 时，必须有一个 <code>value</code> 且不可改变；</p></li><li><p>当 promise 状态由 <code>pending</code> 转变为 <code>rejected</code> 时，必须有一个 <code>reason</code> 且不可改变；</p></li><li><p><code>value</code> 和 <code>reason</code> 的 “不可改变”是指 指向不变，非 deep 层级的不可改变。</p><blockquote><p>Here, “must not change” means immutable identity (i.e. <code>===</code>), but does not imply deep immutability.</p></blockquote></li></ol><p>代码实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 3个状态</span><br><span class="line">const stateEnum = &#123;</span><br><span class="line">  PENDING: &#x27;PENDING&#x27;,</span><br><span class="line">  FULFILLED: &#x27;FULFILLED&#x27;,</span><br><span class="line">  REJECTED: &#x27;REJECTED&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this.state = stateEnum.PENDING; // 当前状态，初始为 pending</span><br><span class="line">    this.value = null; // 状态转变为 fulfilled 时的 value</span><br><span class="line">    this.reason = null; // 状态转变为 rejected 时的 reason</span><br><span class="line"></span><br><span class="line">    // 更改状态；因 resolve/reject 在 executor 中执行，使用箭头函数固定 this 指向</span><br><span class="line">    const resolve = (value) =&gt; &#123;</span><br><span class="line">      // pending =&gt; fulfilled 单向不可逆</span><br><span class="line">      if (this.state === stateEnum.PENDING) &#123;</span><br><span class="line">        this.state = stateEnum.FULFILLED;</span><br><span class="line">        this.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const reject = (reason) =&gt; &#123;</span><br><span class="line">      // pending =&gt; rejected 单向不可逆</span><br><span class="line">      if (this.state === stateEnum.PENDING) &#123;</span><br><span class="line">        this.state = stateEnum.REJECTED;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 立即执行</span><br><span class="line">    try &#123;</span><br><span class="line">      // 传入方法 resolve, reject</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      // 执行异常时，失败回调</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const promise = new MyPromise();</span><br></pre></td></tr></table></figure><h3 id="II-The-then-Method"><a href="#II-The-then-Method" class="headerlink" title="II. The then Method"></a>II. The <code>then</code> Method</h3><ol><li><p>一个 promise 应该提供一个 <code>then</code> 方法，用于获取这个 promise 当前/最终的 value 或 reason；</p></li><li><p><code>then</code> 方法接收两个<strong>可选</strong>参数 <code>onFulfilled</code> 和 <code>onRejected</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></li><li><p>参数 <code>onFulfilled</code> 和 <code>onRejected</code> 均为可执行函数；</p></li><li><p>promise 在 <code>fulfilled</code> 之后调用函数 <code>onFulfilled</code> ，参数为 promise 的 <code>value</code>；</p></li><li><p>promise 在 <code>rejected</code> 之后调用函数 <code>onRejected</code> ，参数为 promise 的 <code>reason</code>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  ...</span><br><span class="line">  then(onFulFilled, onRejected) &#123;</span><br><span class="line">    // onFulFilled / onRejected 必须是函数</span><br><span class="line">    typeof onFulFilled === &#x27;function&#x27; ? onFulFilled : (v) =&gt; v;</span><br><span class="line">    typeof onRejected === &#x27;function&#x27; ? onRejected : (err) =&gt; &#123; throw err &#125;;</span><br><span class="line"></span><br><span class="line">    if (this.state === stateEnum.FULFILLED) onFulFilled(this.value);</span><br><span class="line">    if (this.state === stateEnum.REJECTED) onRejected(this.reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只有当执行栈仅包含平台代码时，<code>onFulfilled</code> 和 <code>onRejected</code> 才可以执行 ;</p><ol><li>用以确保 <code>onFulfilled</code> 和 <code>onRejected</code> 可以异步地在新的执行栈中执行；</li><li>可以通过宏任务（如 <code>setTimeout</code>）、微任务（如 <code>process.nextTick</code>）来实现；</li></ol></li><li><p><code>then</code> 可以被同一个 promise 调用多次；</p><ol><li>当 promise 状态发生改变时，<code>onFulfilled</code> 和 <code>onRejected</code> 必须按其注册顺序依次执行；</li></ol></li><li><p><code>then</code> 函数必须返回一个 promise；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure><ol><li>如果 <code>onFulfilled</code> 或 <code>onRejected</code> 返回一个值（假定为 <code>x</code> ），调用 Promise 解析程序（<code>[[Resolve]](promise2, x)</code>）；</li><li>如果 <code>onFulfilled</code> 或 <code>onRejected</code> 抛出一个异常（假定为 <code>e</code> ），promise2 必须以 <code>e</code> 为 <code>reason</code> 值转变为 <code>rejected</code> 状态；</li><li>如果 <code>onFulfilled</code> 不是函数，且 promise1 已经处于 <code>fulfilled</code> 状态，promise2 必须以和 promise1 相同的 <code>value</code> 转变为 <code>fulfilled</code> 状态；</li><li>如果 <code>onRejected</code> 不是函数，且 promise1 已经处于 <code>rejected</code> 状态，promise2 必须以和 promise1 相同的 <code>reason</code> 转变为 <code>rejected</code> 状态；</li></ol></li></ol><p>代码实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 3个状态</span><br><span class="line">const stateEnum = &#123;</span><br><span class="line">  PENDING: &#x27;PENDING&#x27;,</span><br><span class="line">  FULFILLED: &#x27;FULFILLED&#x27;,</span><br><span class="line">  REJECTED: &#x27;REJECTED&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  // 构造函数，参数为可执行函数</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this.state = stateEnum.PENDING; // 当前状态，初始为 pending</span><br><span class="line">    this.value = null; // 状态转变为 fulfilled 时的 value</span><br><span class="line">    this.reason = null; // 状态转变为 rejected 时的 reason</span><br><span class="line"></span><br><span class="line">    // 更改状态；因 _resolve/_reject 在 executor 中执行，使用箭头函数固定 this 指向</span><br><span class="line">    const _resolve = (value) =&gt; &#123;</span><br><span class="line">      // pending =&gt; fulfilled 单向不可逆</span><br><span class="line">      if (this.state === stateEnum.PENDING) &#123;</span><br><span class="line">        // 状态变化</span><br><span class="line">        this.state = stateEnum.FULFILLED;</span><br><span class="line">        this.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const _reject = (reason) =&gt; &#123;</span><br><span class="line">      // pending =&gt; rejected 单向不可逆</span><br><span class="line">      if (this.state === stateEnum.PENDING) &#123;</span><br><span class="line">        // 状态变化</span><br><span class="line">        this.state = stateEnum.REJECTED;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      // 立即执行 executor 并传入实参 _resolve, _reject</span><br><span class="line">      executor(_resolve, _reject);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      // 执行异常时，失败回调</span><br><span class="line">      _reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulFilled, onRejected) &#123;</span><br><span class="line">    // onFulFilled / onRejected 必须是函数</span><br><span class="line">    typeof onFulFilled === &#x27;function&#x27; ? onFulFilled : (v) =&gt; v;</span><br><span class="line">    typeof onRejected === &#x27;function&#x27; ? onRejected : (err) =&gt; &#123; throw err &#125;;</span><br><span class="line"></span><br><span class="line">    if (this.state === stateEnum.FULFILLED) onFulFilled(this.value);</span><br><span class="line">    if (this.state === stateEnum.REJECTED) onRejected(this.reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const promise = new MyPromise();</span><br></pre></td></tr></table></figure><p>至此，我们已经实现了一个简单的 Promise 。简单验证如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const result = &#x27;resolve&#x27;;</span><br><span class="line">const promise = new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">  if (result === &#x27;fulfilled&#x27;) &#123;</span><br><span class="line">    resolve(&#x27;fulfilled&#x27;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(&#x27;rejected&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;fulfilled value:&#x27;, res);</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;rejected reason:&#x27;, err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>程序正常，没有问题。</p><p>但是，参考 Promises/A+ 标准和正常 Promise 的使用方式，这个 Promise 还是存在许多问题：</p><ol><li><p>上述 6、7、8 条标准未实现；</p></li><li><p>由于 executor 中可能存在异步操作，以至于 then 执行时，promise 可能仍然处于 <code>pending</code> 状态，也就是说，<code>onFulfilled</code> 和 <code>onRejected</code> 的执行时机有问题；</p></li><li><p>按上述规则 No.6（Promises/A+ 2.2.4）的要求，<code>onFulfilled</code> 和 <code>onRejected</code> 需要异步调用，这里是同步。</p><blockquote><p>Promises/A+ 3.1 “In practice, this requirement ensures that <code>onFulfilled</code> and <code>onRejected</code> execute asynchronously”</p></blockquote></li></ol><p>我们姑且先解决问题 2 和 3，规则 No.6 和 No.7。至于规则 No.8，等我们阅读完 <a href="#III">III. The Promise Resolution Procedure</a> 这一部分再来解决。</p><h4 id="A-解决异步-executor-的问题"><a href="#A-解决异步-executor-的问题" class="headerlink" title="A. 解决异步 executor 的问题"></a>A. 解决异步 <code>executor</code> 的问题</h4><p>来捋一捋思路：</p><ol><li>在我们 <code>promise.then()</code> 时，<code>then</code> 就已经执行，我们能做的就是将延迟执行 <code>then</code> 的两个函数参数 <code>onFulfilled</code> 和 <code>onRejected</code> ，而不是延迟 <code>then</code> ；</li><li><code>resolve</code> 和 <code>reject</code> 在 <code>executor</code> 内部执行，按正常的 Promise 的用法，就是在异步函数的最后执行。那么，不妨将 <code>onFulfilled</code> 和 <code>onRejected</code> 放到 <code>resolve</code> / <code>reject</code> 中执行以达到延迟执行的目的；</li></ol><p>代码实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  // 构造函数，参数为可执行函数</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this.state = stateEnum.PENDING; // 当前状态，初始为 pending</span><br><span class="line">    this.value = null; // 状态转变为 fulfilled 时的 value</span><br><span class="line">    this.reason = null; // 状态转变为 rejected 时的 reason</span><br><span class="line">    this.onFulfilled = v =&gt; v; // 存储，以延迟执行</span><br><span class="line">    this.onRejected = v =&gt; v; // 存储，以延迟执行</span><br><span class="line"></span><br><span class="line">    // 更改状态；因 _resolve/_reject 在 executor 中执行，使用箭头函数固定 this 指向</span><br><span class="line">    const _resolve = (value) =&gt; &#123;</span><br><span class="line">      // pending =&gt; fulfilled 单向不可逆</span><br><span class="line">      if (this.state === stateEnum.PENDING) &#123;</span><br><span class="line">        // 状态变化</span><br><span class="line">        this.state = stateEnum.FULFILLED;</span><br><span class="line">        this.value = value;</span><br><span class="line">        // 状态改变时执行</span><br><span class="line">        this.onFulfilled();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const _reject = (reason) =&gt; &#123;</span><br><span class="line">      // pending =&gt; rejected 单向不可逆</span><br><span class="line">      if (this.state === stateEnum.PENDING) &#123;</span><br><span class="line">        // 状态变化</span><br><span class="line">        this.state = stateEnum.REJECTED;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">        // 状态改变时执行</span><br><span class="line">        this.onRejected();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      // 立即执行 executor 并传入实参 _resolve, _reject</span><br><span class="line">      executor(_resolve, _reject);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      // 执行异常时，失败回调</span><br><span class="line">      _reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    // onFulfilled / onRejected 必须是函数</span><br><span class="line">    typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : (v) =&gt; v;</span><br><span class="line">    typeof onRejected === &#x27;function&#x27; ? onRejected : (err) =&gt; &#123; throw err &#125;;</span><br><span class="line"></span><br><span class="line">    switch (this.state) &#123;</span><br><span class="line">      case stateEnum.FULFILLED:</span><br><span class="line">        onFulfilled(this.value);</span><br><span class="line">        break;</span><br><span class="line">      case stateEnum.REJECTED:</span><br><span class="line">        onRejected(this.reason);</span><br><span class="line">        break;</span><br><span class="line">      case stateEnum.PENDING:</span><br><span class="line">        // 当状态为 pending 时，存储而不执行</span><br><span class="line">        // 使用箭头函数嵌套，确定 this 指向</span><br><span class="line">        this.onFulfilled = () =&gt; &#123;</span><br><span class="line">          onFulfilled(this.value);</span><br><span class="line">        &#125;</span><br><span class="line">        this.onRejected = () =&gt; &#123;</span><br><span class="line">          onRejected(this.value);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给 MyPromise 类新增了两个属性 <code>onFulfilled</code> 和 <code>onFulfilled</code>，在 <code>then</code> 执行时，若 <code>promise</code> 的状态仍为 <code>pending</code>，那么把 <code>then</code> 的两个参数存储起来（赋值给 <code>this.onFulfilled</code> 和 <code>this.onRejected</code>），在状态变化（<code>_resolve</code> 或 <code>_reject</code> 执行时）时调用。如此，便可以实现延迟调用、异步执行了。</p><h4 id="B-规则-No-6：onFulfilled-和-onRejected-异步调用"><a href="#B-规则-No-6：onFulfilled-和-onRejected-异步调用" class="headerlink" title="B. 规则 No.6：onFulfilled 和 onRejected 异步调用"></a>B. 规则 No.6：<code>onFulfilled</code> 和 <code>onRejected</code> 异步调用</h4><p>根据 Promises/A+ 规则 3.1 的描述，我们使用 setTimeout 来保证 <code>onFulfilled</code> 和 <code>onRejected</code> 的异步调用。</p><p>代码实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  ...</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    ...</span><br><span class="line">    switch (this.state) &#123;</span><br><span class="line">      ...</span><br><span class="line">      case stateEnum.PENDING:</span><br><span class="line">        this.onFulfilled = () =&gt; &#123;</span><br><span class="line">          // setTimeout 实现异步执行</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            onFulFilled(this.value);</span><br><span class="line">          &#125;, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        this.onRejected = () =&gt; &#123;</span><br><span class="line">          // setTimeout 实现异步执行</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            onFulFilled(this.value);</span><br><span class="line">          &#125;, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-规则-No-7：then-的多次调用"><a href="#C-规则-No-7：then-的多次调用" class="headerlink" title="C. 规则 No.7：then 的多次调用"></a>C. 规则 No.7：<code>then</code> 的多次调用</h4><p>按上述规则 No.7（Promises/A+ 2.2.6），同一个 promise 可以多次调用 then，也就是说会有这种情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  res =&gt; &#123; console.log(&#x27;res-1&#x27;) &#125;,</span><br><span class="line">  err =&gt; &#123; console.log(&#x27;err-1&#x27;) &#125;</span><br><span class="line">);</span><br><span class="line">promise.then(</span><br><span class="line">  res =&gt; &#123; console.log(&#x27;res-2&#x27;) &#125;,</span><br><span class="line">  err =&gt; &#123; console.log(&#x27;err-2&#x27;) &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们目前实现的 Promise ，由于 <code>this.onFulfilled</code> 和 <code>this.onRejected</code> 都是直接赋值的，就导致上面这种用法会有覆盖的风险。</p><p>既然直接赋值的方式不行，不妨使用数组存储。需要时取出执行，之后去除数组元素即可。</p><p>优化代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  // 构造函数，参数为可执行函数</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this.state = stateEnum.PENDING; // 当前状态，初始为 pending</span><br><span class="line">    this.value = null; // 状态转变为 fulfilled 时的 value</span><br><span class="line">    this.reason = null; // 状态转变为 rejected 时的 reason</span><br><span class="line">    this.onFulFilledQueue = []; // fulfilled 时调用的函数执行队列，存储 then 的 onFulFilled 函数</span><br><span class="line">    this.onRejectedQueue = []; // rejected 时调用的函数执行队列，存储 then 的 onRejected 函数</span><br><span class="line"></span><br><span class="line">    // 更改状态；因 _resolve/_reject 在 executor 中执行，使用箭头函数固定 this 指向</span><br><span class="line">    const _resolve = (value) =&gt; &#123;</span><br><span class="line">      // pending =&gt; fulfilled 单向不可逆</span><br><span class="line">      if (this.state === stateEnum.PENDING) &#123;</span><br><span class="line">        // 状态变化</span><br><span class="line">        this.state = stateEnum.FULFILLED;</span><br><span class="line">        this.value = value;</span><br><span class="line">        // 状态改变时执行</span><br><span class="line">        while (this.onFulFilledQueue.length) &#123;</span><br><span class="line">          const cb = this.onFulFilledQueue.shift();</span><br><span class="line">          cb &amp;&amp; cb();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const _reject = (reason) =&gt; &#123;</span><br><span class="line">      // pending =&gt; rejected 单向不可逆</span><br><span class="line">      if (this.state === stateEnum.PENDING) &#123;</span><br><span class="line">        // 状态变化</span><br><span class="line">        this.state = stateEnum.REJECTED;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">        // 状态改变时执行</span><br><span class="line">        while (this.onRejectedQueue.length) &#123;</span><br><span class="line">          const cb = this.onRejectedQueue.shift();</span><br><span class="line">          cb &amp;&amp; cb();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulFilled, onRejected) &#123;</span><br><span class="line">    ...</span><br><span class="line">    switch (this.state) &#123;</span><br><span class="line">      ...</span><br><span class="line">      case stateEnum.PENDING:</span><br><span class="line">        // 当状态为 pending 时，存储而不执行</span><br><span class="line">        // 使用箭头函数嵌套，确定 this 指向</span><br><span class="line">        this.onFulFilledQueue.push(() =&gt; &#123;</span><br><span class="line">          // setTimeout 实现异步执行</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            onFulFilled(this.value);</span><br><span class="line">          &#125;, 0);</span><br><span class="line">        &#125;);</span><br><span class="line">        this.onRejectedQueue.push(() =&gt; &#123;</span><br><span class="line">          // setTimeout 实现异步执行</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            onRejected(this.reason);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，我们采用了发布订阅模式来实现延迟执行。</p><h3 id="III-The-Promise-Resolution-Procedure"><a href="#III-The-Promise-Resolution-Procedure" class="headerlink" title="III. The Promise Resolution Procedure"></a><span id="III">III. The Promise Resolution Procedure</span></h3><p><code>The Promise Resolution Procedure</code>，姑且称之为 Promise 解析程序，函数表示为 <code>[[Resolve]](promise, x)</code></p><p>代码实现如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="IV-then-链式调用与值穿透"><a href="#IV-then-链式调用与值穿透" class="headerlink" title="IV. then 链式调用与值穿透"></a>IV. then 链式调用与值穿透</h3><p>当 then 函数 return 了一个值，我们总能在下一个 then（onFulfilled）中取到，这就是 then 的<strong>链式调用</strong>；</p><p>而如果前一个 then 函数没有传入任何参数（<code>promise.then().then()</code>），则可以在后面的 then 中获取之前 then 返回的值，此即 then 的<strong>值穿透</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><ol><li><p><a href="https://promisesaplus.com/#notes">Promises/A+</a></p></li><li><p><a href="https://segmentfault.com/a/1190000039699000">Promise 知识汇总和面试情况</a></p></li><li><p><a href="https://juejin.cn/post/6850037281206566919">面试官：“你能手写一个 Promise 吗”</a></p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Developer </category>
          
          <category> Language </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】浅谈 Vue 的 diff 算法（未完成）</title>
      <link href="/2021-06-29-vue-diff/"/>
      <url>/2021-06-29-vue-diff/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>diff 是 Vue 执行种的一个重要过程，是深入学习 Vue 时不容忽视的部分。</p><p>本篇文章暂时仅分析 Vue2 的 diff 基本原理，后续考虑补充源码分析和其他框架，如 React、Vue3 的 diff 相关内容，视情况而定。</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>在学习 Diff 算法之前，我们需要先了解几个概念。</p><span id="more"></span><h3 id="1-Virtual-DOM"><a href="#1-Virtual-DOM" class="headerlink" title="1. Virtual DOM"></a>1. Virtual DOM</h3><p>虚拟 DOM（Virtual DOM）是一种将浏览器 DOM 的信息存储在 JavaScript 内存中的方法，是以 JavaScript 对象表示的抽象化的 DOM。</p><p>相比于操作 DOM，通过 JavaScript 操作 Virtual DOM 的开销要小得多。</p><h3 id="2-VNode"><a href="#2-VNode" class="headerlink" title="2. VNode"></a>2. VNode</h3><p>Virtual DOM 为 DOM 的抽象表示。相同的，VNode 就是是 DOM 节点的抽象表示，是 Virtual DOM 的节点。</p><p>VNode 同样也是一个 JavaScript 对象，包括这个 DOM 节点的所有属性内容。</p><h3 id="3-AST"><a href="#3-AST" class="headerlink" title="3. AST"></a>3. AST</h3><p>AST（Abstract Syntax Tree），即抽象语法树，是源代码语法结构的一种抽象表示（树状形式）。树上的每个节点均代表源代码的一种结构。</p><hr><p>Vue 通过编译将模板转换为 AST ，再将 AST 转换为渲染函数，执行渲染函数得到新的 VNode，将其与旧的 VNode 比对，对更改的部分进行更新、替换，最后渲染到页面上。</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/31/171302f6d4189378?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="渲染流程"></p><p>这个比对新旧 VNode，并进行更新、替换的过程就是 diff 的过程。diff 的结果是得到一个新的 VNode 树，用于页面渲染。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>我们不妨设想一下不进行 Diff 的情况。这种情况下我们每次更新页面数据，都需要对页面整体的 DOM 进行渲染，这个消耗是非常大的。</p><p>而 Diff 的作用，就是找到新旧 DOM 的最小差异，尽量减少更新量，最大程度地降低渲染消耗。</p><p>那么，Vue 使用 Diff 的理由也就显而易见了，就是为了减少性能消耗。</p><h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p>传统的 Diff 算法会递归处理每一个节点，计算量非常大。</p><blockquote><p>将两颗树中所有的节点一一对比需要 O(n²)的复杂度，在对比过程中发现旧节点在新的树中未找到，那么就需要把旧节点删除，删除一棵树的一个节点(找到一个合适的节点放到被删除的位置)的时间复杂度为 O(n),同理添加新节点的复杂度也是 O(n),合起来 diff 两个树的复杂度就是 O(n³)</p></blockquote><p>而 React 和 Vue2 的 diff 算法规则大致相同，仅在同级的 VNode 之间做比较计算，递归进行，最终实现整个 DOM 树的更新。</p><p><img src="/2021-06-29-vue-diff/1.png" alt="出自《React’s diff algorithm》"></p><p>diff 算法一般包括几个主要的逻辑，以 3 层嵌套的 DOM 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 简化vdom结构如下</span><br><span class="line">&#123;</span><br><span class="line">  name: &#x27;root&#x27;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#x27;branch-A&#x27;,</span><br><span class="line">      children: [&#123; name: &#x27;leaf-A-1&#x27;, children: [] &#125;],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#x27;branch-B&#x27;,</span><br><span class="line">      children: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>图示如下</p><p><img src="/2021-06-29-vue-diff/A.png" alt="base"></p><h3 id="1-不同节点类型的比较"><a href="#1-不同节点类型的比较" class="headerlink" title="1. 不同节点类型的比较"></a>1. 不同节点类型的比较</h3><p>我们想在二级节点 branch-A 下追加一个三级子节点 leaf-A-2，如下图所示：</p><p><img src="/2021-06-29-vue-diff/B.png" alt="B"></p><p>这种情况仅生成节点 leaf-A-2 并插入到 branch-A 的子节点列表。</p><h3 id="2-删除节点"><a href="#2-删除节点" class="headerlink" title="2. 删除节点"></a>2. 删除节点</h3><h3 id="3-更新节点"><a href="#3-更新节点" class="headerlink" title="3. 更新节点"></a>3. 更新节点</h3><h3 id="Key-的作用"><a href="#Key-的作用" class="headerlink" title="Key 的作用"></a>Key 的作用</h3><hr><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="https://segmentfault.com/a/1190000016129036">你不知道的 Virtual DOM（一）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjQ1NjMwNw==&mid=2247484442&idx=1&sn=26143f93c79390947920a8dc7b84bd14&chksm=f9a66e06ced1e71009a1aacfa134348f3b1e6a2e95a982b09fa2ad5559791650d84aad5eaeb9&token=681836850&lang=zh_CN#rd">【Vue 原理】Diff - 白话版</a></li><li><a href="https://juejin.cn/post/6844904111117336590">《Vue 不看源码懂原理》系列——Vue 的 diff 算法不难懂</a></li><li><a href="https://juejin.cn/post/6854573217462534151">通俗易懂的 vue 虚拟（Virtual ）DOM 和 diff 算法</a></li><li><a href="https://time.geekbang.org/course/detail/100024601-86448">极客时间 《Vue 开发实战 10 | 理解虚拟 DOM 及 key 属性的作用》</a></li><li><a href="https://juejin.cn/post/6966412425843343373">Vue2 Diff 算法深入解读</a></li><li><a href="https://www.infoq.cn/article/react-dom-diff/">深入浅出 React（四）：虚拟 DOM Diff 算法解析</a></li><li><a href="https://juejin.cn/post/6844904145879564296">聊一聊 Diff 算法（React、Vue2.x、Vue3.x）</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Developer </category>
          
          <category> Frame </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TypeScript】interface 与 type 的区别</title>
      <link href="/2021-06-23-interface-type/"/>
      <url>/2021-06-23-interface-type/</url>
      
        <content type="html"><![CDATA[<h2 id="笔者有话要讲"><a href="#笔者有话要讲" class="headerlink" title="笔者有话要讲"></a>笔者有话要讲</h2><p>我们在使用 TypeScript 时，经常会用到这两个声明 <code>interface</code> 和 <code>type</code>，我一直存在一个疑惑，这两个究竟有什么区别，各自又该用在什么场景。</p><p>恰巧关注的公众号——《大迁世界》推送了一篇文章——<a href="https://mp.weixin.qq.com/s?__biz=MzI0NDQ0ODU3MA==&mid=2247500645&idx=1&sn=ddd186406c46dca791fca08e27b82b66&chksm=e95f2f30de28a62687c61e3b6c7c548f700c911d07f287066bb5070b0f8d3e25ed1cec5a69b8&scene=178&cur_album_id=1913322228960526337#rd">《使用 TypeScript 常见困惑：interface 和 type 的区别是什么？》</a>，感觉文章排版有些错乱，看着属实难受。<br>所幸本人还是能看懂一点点英文的（指有道词典），所以干脆找到<a href="https://www.wisdomgeek.com/development/web-development/typescript/typescript-the-difference-between-interface-and-type/">原文</a>直接自己翻（run）译（se）好了，顺便还加了一点点补丁（patch）。</p><hr><p><img src="https://i.loli.net/2021/11/03/FyIeAGB6xKOZECN.jpg" alt="typescript-interface-and-type.jpeg"></p><p>typescript 版本：4.4.4</p><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><h3 id="1-1-类型-Types"><a href="#1-1-类型-Types" class="headerlink" title="1.1. 类型 Types"></a>1.1. 类型 Types</h3><p>我们知道 TypeScript 中有许多类型，有基础的类型如 string, number, 和 boolean，也有特殊的如数组 Arrays、元组 Turple 等等。这些类型使用起来非常简单，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const ExampleStr:string = &#x27;my name&#x27;;</span><br><span class="line">const ExampleArr:number[] = [1, 2, 3];</span><br></pre></td></tr></table></figure><h3 id="1-2-联合类型-Union-Types"><a href="#1-2-联合类型-Union-Types" class="headerlink" title="1.2. 联合类型 Union Types"></a>1.2. 联合类型 Union Types</h3><p>理所当然的，一个变量可能不止一种类型，这种情况在实际开发中并不少见。举个简单的例子，在一些业务中，我们会先声明一个变量，然后通过各种判断给这个变量赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let target = null;</span><br><span class="line">if ([some condition]) &#123;</span><br><span class="line">  target = &#123;a: 1&#125;;</span><br><span class="line">&#125; else if ([anothor condition]) &#123;</span><br><span class="line">  target = &#123;b: 2&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，target 的值开始时是 null 类型，程序执行完毕后是 number 类型。这种情况我们就可以使用<a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types">组合类型</a>，表明 target 可以是 null 也可以是 number。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type ObjType = &#123; a: number &#125;;</span><br><span class="line">let target: null | ObjType = null;</span><br></pre></td></tr></table></figure><h4 id="1-2-1-基本类型联合"><a href="#1-2-1-基本类型联合" class="headerlink" title="1.2.1. 基本类型联合"></a>1.2.1. 基本类型联合</h4><p>基本类型联合，允许访问任意联合成员类型，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let target = string | number;</span><br><span class="line">target = &#x27;a&#x27;; // ok</span><br><span class="line">target = 1; // ok</span><br></pre></td></tr></table></figure><h4 id="1-2-2-对象类型联合"><a href="#1-2-2-对象类型联合" class="headerlink" title="1.2.2. 对象类型联合"></a>1.2.2. 对象类型联合</h4><p>对象类型联合，只能访问联合中共同的成员，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Women &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  say(): void;</span><br><span class="line">&#125;</span><br><span class="line">interface Man &#123;</span><br><span class="line">  name: string,</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">declare function Person(): Women | Man;</span><br><span class="line">let him = Person();</span><br><span class="line">him.name = &quot;Jean&quot;; // ok</span><br><span class="line">him.age = 18; // error 非共同成员</span><br><span class="line">him.say(); // error 非共同成员</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> 有一个值得注意的点，如果我们使用字面量或者整体赋值的方式，而不是 <code>obj.x=xx</code> 的方式给变量赋值，那么赋的这个值至少应包含<strong>联合中一个成员</strong>的<strong>所有</strong>属性/方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">interface B &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  gender: number;</span><br><span class="line">&#125;</span><br><span class="line">// 以下三个声明都不会报错</span><br><span class="line">let c: A | B = &#123;</span><br><span class="line">  name: &#x27;&#x27;,</span><br><span class="line">  gender: 1,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let d: A | B;</span><br><span class="line">d = &#123;</span><br><span class="line">  name: &#x27;&#x27;,</span><br><span class="line">  age: 1,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type C = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;;</span><br><span class="line">const c: C = &#123;</span><br><span class="line">  name: &#x27;&#x27;,</span><br><span class="line">  age: 1,</span><br><span class="line">&#125;;</span><br><span class="line">const d: A | B = c;</span><br></pre></td></tr></table></figure><p>即使通过这种方式赋值，我们也不可以访问对象联合类型的非共有属性/方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let inst: A | B = &#123;</span><br><span class="line">  name: &#x27;&#x27;,</span><br><span class="line">  age: 1;</span><br><span class="line">  gender: 1,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(inst); // &#123; name: &#x27;&#x27;, age: 1, gender: 1 &#125;</span><br><span class="line">inst.age = 2; // 类型“A | B”上不存在属性“age”。</span><br><span class="line">inst.gender = 0; // 类型“A | B”上不存在属性“gender”。</span><br></pre></td></tr></table></figure><h3 id="1-3-交叉类型-Intersection-Types"><a href="#1-3-交叉类型-Intersection-Types" class="headerlink" title="1.3. 交叉类型 Intersection Types"></a>1.3. 交叉类型 Intersection Types</h3><p>与联合类型取交集不同，交叉类型取的并集，即，交叉类型允许访问成员类型的所有属性。   </p><p>自然，交叉类型只能是两个对象类型的交叉，毕竟基本类型也没办法交叉不是。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Women &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  say(): void;</span><br><span class="line">&#125;</span><br><span class="line">interface Man &#123;</span><br><span class="line">  name: string,</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">declare function Person(): Women &amp; Man;</span><br><span class="line">let him = Person();</span><br><span class="line">him.name = &quot;Jean&quot;; // ok</span><br><span class="line">him.age = 18; // ok</span><br><span class="line">him.say(); // ok</span><br></pre></td></tr></table></figure><p>交叉类型对象的赋值必须包含该交叉类型指定的所有属性/方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">interface B &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  gender: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const c: A &amp; B = &#123;</span><br><span class="line">  name: &#x27;&#x27;,</span><br><span class="line">  age: 1,</span><br><span class="line">&#125;;</span><br><span class="line">// 不能将类型“&#123; name: string; age: number; &#125;”分配给类型“A &amp; B”。</span><br><span class="line">// 类型 &quot;&#123; name: string; age: number; &#125;&quot; 中缺少属性 &quot;gender&quot;，但类型 &quot;B&quot; 中需要该属性。</span><br></pre></td></tr></table></figure><h3 id="1-4-类型别名-Type-Aliases"><a href="#1-4-类型别名-Type-Aliases" class="headerlink" title="1.4. 类型别名 Type Aliases"></a>1.4. 类型别名 Type Aliases</h3><p>举个栗子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr1: [string, number] = [&#x27;a&#x27;, 1];</span><br><span class="line">const obj1: &#123; a: string, b: number &#125; = &#123; a: &#x27;a&#x27;, b: 2 &#125;;</span><br><span class="line">const prim1: string | number | boolean = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>在实际的开发过程中，我们或多或少会遇到上面这种写法才能实现的逻辑。这种变量只有一个两个的话还好，如果有大量相同类型的变量，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj1: &#123; a: string, b: number &#125; = &#123; a: &#x27;a&#x27;, b: 2 &#125;;</span><br><span class="line">const obj2: &#123; a: string, b: number &#125; = &#123; a: &#x27;a&#x27;, b: 2 &#125;;</span><br><span class="line">const obj3: &#123; a: string, b: number &#125; = &#123; a: &#x27;a&#x27;, b: 2 &#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>也许写起来还不会太麻烦（ctrl+c/ctrl+v 就好），但是看上去令人强迫症（指“优化”代码）发作。</p><p>TypeScript 自然也提供了解决方案，那就是 <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases">类型别名 Type Aliases</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type CommonType = &#123; a: string, b: number &#125;;</span><br><span class="line">const obj1: CommonType = &#123; a: &#x27;a&#x27;, b: 2 &#125;;</span><br><span class="line">const obj2: CommonType = &#123; a: &#x27;a&#x27;, b: 2 &#125;;</span><br><span class="line">const obj3: CommonType = &#123; a: &#x27;a&#x27;, b: 2 &#125;;</span><br></pre></td></tr></table></figure><p>类型别名允许我们通过一个名称来使用一些或简单（正常会用在基本类型上么？）或复杂的类型，这样无论是编写难易度还是代码美观程度上，都比之前那种写法好得多。</p><h3 id="1-5-接口-Interfaces"><a href="#1-5-接口-Interfaces" class="headerlink" title="1.5. 接口 Interfaces"></a>1.5. 接口 Interfaces</h3><p>官方文档中的解释：<code>An interface declaration is another way to name an object type</code>。interface 是声明<strong>对象</strong>类型的一种方式。</p><p>举个栗子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type CommonType = &#123; a: string, b: number &#125;;</span><br><span class="line">// 也可以写成</span><br><span class="line">interface CommonType &#123;</span><br><span class="line">  a: string,</span><br><span class="line">  b: number,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、相同点-type-and-interface"><a href="#二、相同点-type-and-interface" class="headerlink" title="二、相同点 type and interface"></a>二、相同点 type and interface</h2><ol><li><p>都可以声明对象类型；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface PointA &#123;</span><br><span class="line">  x: number;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line">type PointB = &#123;</span><br><span class="line">  x: number;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>都可以被实现（implements）;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface InterfaceA &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;;</span><br><span class="line">class PersonA implements InterfaceA &#123;</span><br><span class="line">  name = &#x27;Kaze&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type TypeB = &#123; age: number &#125;;</span><br><span class="line">class PersonB implements TypeB &#123;</span><br><span class="line">  age = 17;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>都可以联合、交叉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type A = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">type B = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  isMale: boolean;</span><br><span class="line">&#125;</span><br><span class="line">let Person1: A | B;</span><br><span class="line">let Person2: A &amp; B;</span><br><span class="line">// interface 也可以</span><br><span class="line">interface A &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">interface B &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  isMale: boolean;</span><br><span class="line">&#125;</span><br><span class="line">let Person1: A | B;</span><br><span class="line">let Person2: A &amp; B;</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、不同点-type-vs-interface"><a href="#三、不同点-type-vs-interface" class="headerlink" title="三、不同点 type vs interface"></a>三、不同点 type vs interface</h2><div class="tabs" id="vs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#vs-1">声明</button></li><li class="tab"><button type="button" data-href="#vs-2">使用方式</button></li><li class="tab"><button type="button" data-href="#vs-3">继承</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="vs-1"><ol><li><p>声明语法不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type A = &#123; name: string &#125;;</span><br><span class="line">type B = [string, number];</span><br><span class="line">type C = string;</span><br><span class="line"></span><br><span class="line">interface D &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重复声明效果不同</p><ol><li><p><span id="merge">interface 重复声明会合并，同名替换</span> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  gender: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Person &#123;</span><br><span class="line">  age: number;</span><br><span class="line">  gender: number;</span><br><span class="line">&#125;</span><br><span class="line">// 等同于</span><br><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>type 重复声明会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type One = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line">type One = &#123;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">// 报错：Duplicate identifier &quot;One&quot;</span><br></pre></td></tr></table></figure></li></ol></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vs-2"><p>interface 只针对对象类型，而 type 则没有此限制（毕竟只是个别名而已）。举个栗子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type ArrType = [string, number];</span><br><span class="line">// interface 是不能直接声明数组的</span><br><span class="line">interface ArrType [string, number]; // 语法错误</span><br><span class="line"></span><br><span class="line">// 当然，你可以通过嵌套方式实现该效果，但。。。</span><br><span class="line">interface ObjType &#123;</span><br><span class="line">  arr: [string, number]</span><br><span class="line">&#125;</span><br><span class="line">const obj:ObjType = &#123;</span><br><span class="line">  arr: [&#x27;a&#x27;, 1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你甚至可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  gender: string;</span><br><span class="line">&#125;</span><br><span class="line">type One = Person;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vs-3"><p>interface 和 type 都可以实现继承，甚至 interface 和 type 之间也可以相互继承，但语法有所区别。</p><ol><li><p>Interface 继承 interface：使用 extends 关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface B extends A &#123;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>interface 继承 type：同样使用 extends 关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type A = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface B extends A &#123;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>type 继承 type：交叉类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type A = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line">type B = A &amp; &#123;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>type 继承 interface：交叉类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line">type B = A &amp; &#123;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在大多数情况下，你可以根据个人偏好进行选择，TypeScript 会告诉你是否需要其他类型的声明。<a href="#reference-3"><sup>[3]</sup></a></p><p>如果您想使用启发式方法（heuristic），除部分需要使用 type 特性的情况外，请使用接口 interface。<a href="#reference-3"><sup>[3]</sup></a></p><p>对于库中的公共 API 定义或者第三方类型定义，应使用接口（<a href="#merge">声明合并</a>功能）。</p><p>除此之外，我们可以随意使用，但在整个项目中应<strong>保持一致性</strong>。</p><p>这就是 TypeScript 中关于接口 vs 类型的所有知识。 希望这篇文章能帮到你，如果对你有所帮助的话，请分享给你的朋友!</p><hr><p>参考文献:</p><blockquote><p>[1] <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases">TypeScript 官方文档#type-aliases</a></p><p>[2] <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces">TypeScript 官方文档#interfaces</a></p><p>[3] <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces">TypeScript 官方文档#Differences Between Type Aliases and Interfaces</a></p><p>[4] <a href="https://mp.weixin.qq.com/s?__biz=MzI0NDQ0ODU3MA==&mid=2247500645&idx=1&sn=ddd186406c46dca791fca08e27b82b66&chksm=e95f2f30de28a62687c61e3b6c7c548f700c911d07f287066bb5070b0f8d3e25ed1cec5a69b8&scene=178&cur_album_id=1913322228960526337#rd">使用 TypeScript 常见困惑：interface 和 type 的区别是什么？</a></p><p>[5] <a href="https://www.wisdomgeek.com/development/web-development/typescript/typescript-the-difference-between-interface-and-type/">[SARANSH KATARIA]TypeScript: the difference between interface and type</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Developer </category>
          
          <category> Language </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue】如何在 Vue3 中使用 keep-alive 缓存页面</title>
      <link href="/2021-06-18-vue3-keep-alive/"/>
      <url>/2021-06-18-vue3-keep-alive/</url>
      
        <content type="html"><![CDATA[<h2 id="如何在-Vue3-项目中使用-keep-alive-组件"><a href="#如何在-Vue3-项目中使用-keep-alive-组件" class="headerlink" title="如何在 Vue3 项目中使用 keep-alive 组件"></a>如何在 Vue3 项目中使用 keep-alive 组件</h2><h3 id="为什么要写这篇文章？"><a href="#为什么要写这篇文章？" class="headerlink" title="为什么要写这篇文章？"></a>为什么要写这篇文章？</h3><p>最近在学习 Vue3 的使用，在使用 <code>vue-router</code> 插件时，想到组件缓存的问题。我想要实现的效果是，搭配 <code>vue-router</code>， 定义路由表时，在 <code>meta</code> 中添加 <code>keepAlive</code> 变量，并通过 <code>route.meta.keepAlive</code> 这一变量控制页面组件的缓存与否，这也是使用 Vue2 时的缓存思路。</p><p>在使用 <code>&lt;keep-alive&gt;</code> 时遇到了一些问题。</p><span id="more"></span><p>我首先习惯性地尝试使用 Vue2 的方式使用 <code>&lt;keep-alive&gt;</code> 处理需要缓存的组件 ，但 Vue3 中，<code>&lt;keep-alive&gt;</code> 的使用方式与 Vue2 有所不同，Vue2 的使用方式并不能实现组件缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/keep-alive&gt;</span><br><span class="line">  &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><span id="method-2">查阅</span>网上的一些文章，对 Vue3 的 <code>&lt;keep-alive&gt;</code> 使用与 Vue2 不同这一点基本都有提及，但代码大多都是这种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;component :is=&quot;Component&quot; v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/component&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">    &lt;component :is=&quot;Component&quot; v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>这种方式在某些情况下的组件渲染有问题：页面 A 非缓存，页面 B、C 缓存，A=&gt;B=&gt;A=&gt;C 时，A 和 C 会一起被渲染。</p><p>还有这种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;</span><br><span class="line">    &lt;keep-alive include=&quot;A,C&quot;&gt;</span><br><span class="line">      &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">  &lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>这种方式虽然缓存效果得以实现，但放弃了使用 keepAlive 属性，与我们想要实现的逻辑实在是南辕北辙。</p><p>多番思虑后，终于从 vue-router 的<a href="https://next.router.vuejs.org/zh/api/#route">官方文档</a>中找到解决方案，故写了这边文章用以记录。</p><h3 id="lt-keep-alive-gt-组件简介"><a href="#lt-keep-alive-gt-组件简介" class="headerlink" title="&lt;keep-alive&gt; 组件简介"></a><code>&lt;keep-alive&gt;</code> 组件简介</h3><p><code>&lt;keep-alive&gt;</code> 的作用，熟悉 Vue2 的同学必然不会陌生，这里也就不再赘述。</p><p>值得一说的是，<code>&lt;keep-alive&gt;</code> 有几个需要注意的点，列在下面：</p><ol><li><code>&lt;keep-alive&gt;</code> 要求同时只有一个子元素被渲染；</li><li><code>&lt;keep-alive&gt;</code> 是用在其一个直属的子组件被切换的情形，如果你在其中有 <code>v-for</code> 则不会工作；</li><li>属性 <code>include</code> 和 <code>exclude</code> 允许组件有条件地缓存，其匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)。<strong>匿名组件不能被匹配</strong>。</li><li><code>&lt;keep-alive&gt;</code> 不会在<strong>函数式组件</strong>中正常工作，因为它们没有缓存实例。</li></ol><h3 id="Vue2-的使用方式"><a href="#Vue2-的使用方式" class="headerlink" title="Vue2 的使用方式"></a>Vue2 的使用方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/keep-alive&gt;</span><br><span class="line">  &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="Vue3-的使用方式"><a href="#Vue3-的使用方式" class="headerlink" title="Vue3 的使用方式"></a>Vue3 的使用方式</h3><p>注意 key 的使用，解决上述<a href="#method-2">方法 2</a>的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;router-view v-slot=&quot;&#123; Component, route &#125;&quot;&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;component</span><br><span class="line">        v-if=&quot;route.meta.keepAlive&quot;</span><br><span class="line">        :is=&quot;Component&quot;</span><br><span class="line">        :key=&quot;route.path&quot;</span><br><span class="line">      &gt;&lt;/component&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">    &lt;component</span><br><span class="line">      v-if=&quot;!route.meta.keepAlive&quot;</span><br><span class="line">      :is=&quot;Component&quot;</span><br><span class="line">      :key=&quot;route.path&quot;</span><br><span class="line">    &gt;&lt;/component&gt;</span><br><span class="line">  &lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Developer </category>
          
          <category> Frame </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
            <tag> Vue Router </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
